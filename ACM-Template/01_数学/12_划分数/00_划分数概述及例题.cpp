// ---
// 一、适用问题\\
// 只要涉及一些难以用组合公式直接求得的数的划分问题。比如将 $n$ 个数划分成多个不大于 $m$ 的划分方法，且不存在相同数。或者划分成若干奇数或偶数的问题。\\
// \\
// 划分要求千变万化，主要识别点在于将划分数类比为盒子与球的问题，类比成多个球放到多个盒子中，且球和盒子都没有区别。\\
// \\
// 这类问题与一般的划分问题都不同，需要二维 $dp$ 求解，有时还需要处理前缀和进行计算。\\
// \\
// 二、算法举例\\
// (1) 将 $n$ 个数划分成多个不大于 $m$ 的数，可以存在相同整数\\
// \\
// $f[n][m]$ 表示整数 $n$ 的划分中，每个数都不大于 $m$ 的划分方案。转移时可以分成两种情况，第一种情况，划分方案中每个数都小于 $m$，因此划分方案为 $f[n][m-1]$。\\
// \\
// 第二种情况，划分方案中至少有一个数为 $m$，即在 $n$ 中减去 $m$，得到 $f[n-m][m]$。\\
// \\
// $f[n][m]=f[n][m-1]+f[n-m][m]$\\
// \\
// (2) 将 $n$ 个数划分成多个不大于 $m$ 的数，不能存在相同整数\\
// \\
// 这个问题和上一个问题唯一的区别就在于不能存在相同整数，因此只需要修改第二种情况即可实现正确的转移。\\
// \\
// $f[n][m]=f[n][m-1]+f[n-m][m-1]$\\
// \\
// (3) 将 $n$ 个数划分成 $k$ 个数的划分方案\\
// \\
// 考虑 $k$ 个数中是否存在 $1$。第一种情况从 $n$ 个数中取出 $k$ 个，保证剩下 $k$ 组中每组数大于等于 $2$。第二种情况则保证 $k$ 份中有至少一个 $1$，即先取出一个 $1$ 分成 $k-1$ 组。\\
// \\
// $f[n][k]=f[n-k][k]+f[n-1][k-1]$\\
// \\
// (4) 将 $n$ 个数划分成不超过 $k$ 个数的划分方案\\
// \\
// 此处枚举的是划分方案中是否有 $k$ 组，$f[n][k]$ 分别由划分组数小于 $k$ 和划分组数等于 $k$ 两种情况转移而来。\\
// \\
// $f[n][k]=f[n-k][k]+f[n][k-1]$\\
// \\
// (5) 将 $n$ 个数划分若干奇数/偶数的划分方案\\
// \\
// $g[n][m]$：将 $n$ 划分为 $m$ 个偶数的方案\\
// $f[n][m]$：将 $n$ 划分为 $m$ 个奇数的方案\\
// \\
// 求 $g[n][m]$ 只需从 $n$ 中取出 $m$ 个，然后将 $f[n-m][m]$ 中的每个数$+1$，从奇数变成偶数即可。 求 $f[n][m]$ 则需要考虑划分方案中有无 $1$ 的情况，因为直接从 $g[n-m][m]$ 转移过来，会丢失有 $1$ 的这种情况。 \\
// $g[n][m]=f[n-m][m]$ \\
// \\
// $f[n][m]=f[n-1][m-1]+g[n-m][m]$\\
// \\
// (6) 将 $n$ 个数划分成若干个数，使这若干个数的乘积最大\\
// \\
// 1. 对于任意大于等于 $4$ 的正整数 $m$，可以划分成 $m=m_1+m_2$，使得 $m_1*m_2\geq m$。\\
// \\
// 证明：令 $m_1=(int)m/2,m_2=m-m_1$，$m_1\geq 2,m_2\geq m_1$ 且 $m_2> 2$，则 $m_1*m_2\geq 2*m_2\geq m$。\\
// \\
// 2. 因此不断这样拆分下去，最后剩下的数一定是很多个 $2$ 和 $3$ 的组合，即 $ans = 2^r*3^s$，且 $r\leq 2$。\\
// \\
// 若 $r>2$，则至少有 $3$ 个因子为 $2$，而 $2*2*2<3*3$，且 $2+2+2=3+3$，因此 $r\leq 2$。\\
// \\
// 3. 至此为止，不难发现答案只需对小于 $4$ 的数分类讨论，对于大于 $4$ 的数，枚举 $2$ 的最少个数即可。\\
// \\
// $n=3*r$，$ans = 3^r$\\
// $n=3*r+1$，$ans=3^{r-1}*2*2$\\
// $n=3*r+2$，$ans=3^r*2$\\
// \\
// (7) 将 $n$ 个数划分成若干个不同的数，使这若干个数的乘积最大\\
// \\
// 1. 拆分成的数的个数越多，乘积越大。因此找到第一个大于等于 $n$ 的 $S_x = \sum\limits_{i=2}^{x}i$。\\
// 2. 若 $S_x=n$，则 $S_x$ 即为划分答案。\\
// 3. 若 $S_x = n+1$，则将 $S_x$ 中的 $2$ 去掉，令 $x$ 变成 $x+1$，即为最大值。\\
// 4. 若 $S_x>n+1,k=S_x-n$，则答案为将 $S_x$ 序列中的 $k$ 去掉，剩下数构成最终答案。\\
// \\
// 三、例题\\
// 题意: 给出一个 $\text{H}$ 行 $\text{N}$ 列的网格，$(r,c)$ 指第 $r$ 行第 $c$ 列的格子。现在需要在网格中选择 $\text{N}$ 个格子涂成黑色。这 $\text{N}$ 个格子需要满足一定的条件。\\
// 1. $(1,1)$ 需要涂黑。\\
// 2. 如果 $(r,a)$ 与 $(r,b)$ 涂黑了，则 $(r,k)$ 为黑。$a<k<b$，即每行涂黑的格子必须是连续的。\\
// 3. 如果 $(r,c)$ 涂黑了，则 $(r-1,c)$ 如果存在，也必须涂黑。\\
// 4. 如果 $(r,c)$ 涂黑了，并且现在没有任何 $k<c$ 使得 $(r,k)$ 是黑的，则 $(r+1,c)$ 为白。\\
// \\
// 稍加模拟就会发现满足如上条件的格子组成了一个金字塔形状。如下图所示。\\
// 先要求给出一个 $\text{H}$ 和 $\text{N}$，求出有多少种不同的涂法满足条件，答案模 $10^9+7$。$(1\leq \text{H},\text{N}\leq 10^5)$\\
// \\
// 思路: 首先不难发现，若想满足题意进行格子涂色，则每行涂色的格子数必定逐行递减，因此可以发现涂色格子的行数一定在 $\sqrt \text{N}$ 级别，即最多不会超过 $400$。\\
// \\
// 然后观察这个问题，这是个计数问题，比较常见的考虑就是使用 $dp$ 进行转移计算答案。而使用 $dp$ 的话，我们的选择就无非是按行从上往下 $dp$ 转移，或者按列从左往右 $dp$ 转移。（不过比赛的时候绝大多数想到的都只有按行从上往下）\\
// \\
// 如果按行从上往下转移，那怎么想都需要一个三维 $dp$，$dp[i][j][k]$，第 $i$ 行，有 $j$ 个格子，还剩 $k$ 个格子没有填的方案数，然后就可以全队自闭了。思路陷在这里如果出不来就基本是告别 $AC$ 了。\\
// \\
// 既然行不可行，我们来考虑列转移，从左往右进行列的 $dp$ 转移。我们从最高点将左右两边的金字塔划开，发现左边的金字塔列是不断递增上来的，即前一个与后一个要么高度不变，要么高度 $+1$。而右边的金字塔则只是递增，并没有严格的 $+1$ 关系。\\
// \\
// 因此我们考虑对于左右两边进行分开 $dp$。左边状态为 $f[i][j]$，表示 $i$ 个数，最大的数为 $j$ 的方案个数，并且在转移过程严格要求一个数列非递减关系。而定义右边状态为 $s[i][j]$，表示 $i$ 个数，所有的数小于等于 $j$ 的方案个数。然后来分别思考转移方程。\\
// \\
// 左半部分转移方程，由于必须满足划分的数为非递减关系，因此我们枚举前一个数为 $j$ 或 $j-1$，因此得到如下转移方程。\\
// \\
// $f[0][0] = 1$ \\
// \\
// $f[i][j]=f[i-j][j]+f[i-j][j-1]$ \\
// \\
// 右半部分转移方程，只需满足所有数小于等于 $j$，因此可以类比之前的经典模型，$i$ 个数进行划分，最大的数不超过 $j$ 的划分方案数。\\
// \\
// $s[0][i] = 1$ \\
// \\
// $s[i][j] = s[i][j-1]+s[i-j][j]$\\
// \\
// 最后，枚举高度，然后再枚举左半部分格子数统计答案即可。\\
// ---
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i = a; i <= b; i++)
const int N = 1e5+100;
const int mod = 1e9+7;
using namespace std;

int n,h,f[N][460],s[N][460];

void init(){
    //f[i][j]: i个数, 最大的数为j, 方案个数
    f[0][0] = 1;
    rep(i,1,100000)
        rep(j,1,min(i,455)){
            f[i][j] = (f[i-j][j]+f[i-j][j-1])%mod;
        }

    //s[i][j]: i个数, 所有的数小于等于j, 方案个数
    rep(i,0,455) s[0][i] = 1;
    rep(i,1,100000){
        rep(j,1,455){
            s[i][j] = s[i][j-1];
            if(i >= j) s[i][j] = (s[i][j]+s[i-j][j])%mod;
        }
    }
}

int main()
{
    init(); 
    scanf("%d%d",&h,&n);
    long long ans = 0;
    //一开始先枚举高度, 整个题的思路也是这样, 但是根据内存连续性的问题, 必T无疑...我也成功找了一个小时bug才找到...
    //今后枚举数组时, 务必记得先枚举行, 再枚举列, 谨记今日教训
    rep(i,1,n)
        rep(j,1,min(h,455))
            ans = (ans+1ll*f[i][j]*s[n-i][j-1])%mod;
    printf("%lld\n",ans);
    return 0;
}