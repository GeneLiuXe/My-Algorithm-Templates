// ---
// 一、KMP求解过程\\
// \\
// next数组 —— 最长前缀后缀匹配长度，需要小于串长度\\
// \\
// $ababa$，$next[1] = 0, next[2] = 0, next[3] = 1, next[4] = 2, next[5] = 3 $\\
// \\
// 求解问题：模式串在匹配串的哪些位置出现了，模式串是小串。\\
// \\
// 二、例题\\
// \\
// (1) 求取num数组，表示最长的，不超过一半的，前缀与后缀相同的长度。$(1\leq n\leq 10^6)$\\
// \\
// 一个显然的性质：$num[i]\leq num[i-1]+1$\\
// 因此求取 $num[i]$ 时，先令 $num[i]=num[i-1]+1$，如果 $num[i]$ 超过一半的长度或者在 $num[i]$ 处发生失配，则直接跳 $next$ 数组。\\
// \\
// (2) 给出 $n$ 个串，每个串的长度为 $m_i$，询问这 $n$ 个串的最长公共子串。此处两个子串相同的条件为，长度相同且其中一个子串加上一个数即可得到另一个子串。$(1\leq n\leq 1000,1\leq m_i\leq 100)$ \\
// \\
// 1. 在差分序列上进行 $kmp$ 匹配。\\
// 2. 这里由于数据范围比较小，因此可以直接枚举后缀进行 $kmp$ 匹配求最小值。\\
// 3. 但是多个串的最长公共子串其实是一个经典问题，可以用后缀数组或后缀自动机解决。\\
// ---
//预处理next数组，这里注意不要反复求strlen，这个函数是O(n)复杂度的，反复求会将复杂度变成 O(n^2)
next[0] = -1;
for(int i = 1, j; i <= n; i++){
  for(j = next[i-1]; j >= 0 && s1[j+1] != s1[i]; j = next[j]);
  next[i] = j+1;
}
//next[j] <= next[j-1]+1, 不会比前一位+1更大
//匹配过程
for(int i=1, j=0; i <= m; i++){
  for(; s2[i] != s1[j+1] && j >= 0; j = next[j]);
  j++;
  if(j==n) ans++;
}