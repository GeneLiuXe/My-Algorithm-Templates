// ---
// 一、适用问题: \\
// \\
// $Manacher$ 算法主要解决的是给出一个字符串，$O(n)$ 复杂度下求出以字符串中任意一个节点为中心所能扩展的最大距离。\\
// \\
// 二、$Manacher$ 算法解析 \\
// \\
// (1) 扩充字符串\\
// 为了统一奇偶字符串，算法首先在每两个字符（包括头尾）之间加没出现的字符（如*），这样所有字符串长度就都是奇数了，简化了问题。\\
// 例如: $abcde\longrightarrow *a*b*c*d*e*$ \\
// \\
// (2) 具体 $dp$ 过程\\
// 记录 $p_i$ 表示 $i$ 能向两边推（包括 $i$）的最大距离，如果能求出 $p$ 数组，那每一个回文串就都确定了。\\
// \\
// 我们假设 $p[1～i]$ 已经求好了，现在要求 $p[i]$。假设之前能达到的最右边为 $R$，对应的中点为 $pos$，$j$ 是 $i$ 的对称点。\\
// 1. 第一种情况，$i+p[j]<R$，即 $p[i]=p[j]$。\\
// 2. 第二种情况，$i+p[j]\geq R$，先设 $p[i]=R-i$ ，然后再继续增加 $p[i]$，并令 $pos=i$，更新 $R$。\\
// \\
// 由于 $R$ 一定是递增的，因此时间复杂度为 $O(n)$，可以发现一个串本质不同的回文串最多有 $n$ 个，因此只有 $R$ 增加的时候才会产生本质不同的回文串。\\
// \\
// (3) 算法特点 \\
// 1. $Manacher$ 充分利用了回文的性质，从而达到线性时间。\\
// 2. $Manacher$ 右端点递增过程中产生了所有的本质不同回文串，即一个串中本质不同回文串最多只有 $n$ 个。\\
// 3. $Manacher$ 算法的核心在于求出每一个节点往两边推的最远距离，所有涉及该算法的问题也都是在这个功能上做文章。\\
// ---
void Manacher(char s1[]){
	int len, tot, R = 0, pos = 0;
	//对字符串加'#'号
	len = strlen(s1+1);
	s2[0] = '$';
	s2[ln=1]='#';
	for(int i = 1; i <= len; i++)
	  s2[++ln] = s1[i], s2[++ln] = '#';
	//求p[i]数组
	for(int i = 1; i <= ln; i++){
	  if(R >= i) p[i] = min(p[pos*2-i],R-i+1);
		if(p[i] + i > R){
	    for(; s2[R+1] == s2[i*2-R-1] && R+1 <= ln && i*2-R-1 <= ln; R++); //小心多组数据
	    pos = i;
	    p[i] = R-i+1;
	  }
	}
}