// ---
// 适用问题: \\
// 树上启发式合并作为树上问题三剑客之一（点分治、长链剖分），以其优雅的暴力而闻名于江湖之中。\\
// \\
// 通常来说，如果一个问题可以被划分为一个个子树进行求解的问题，而且各个子儿子对答案的贡献容易添加与删除，就可以考虑使用树上启发式合并来求解。\\
// \\
// 本文主要介绍树上启发式合并的一些习题，可以从习题中仔细感受该算法的一系列特点。\\
// \\
// 算法介绍: \\
// 树上启发式合并需要两次 $dfs$，第一次 $dfs$ 进行重链剖分，第二次 $dfs$ 进行求解。\\
// \\
// 通常有一个全局的数组用于信息记录。$dfs$ 之前，需要将这个数组赋初值。$dfs$ 时，先递归处理轻儿子，处理完之后清空轻儿子，最后再处理重儿子，处理完之后不清空。\\
// \\
// 计算完儿子的答案之后，再递归所有轻儿子，边递归边计算答案，并将轻儿子的信息添加到全局数组中。\\
// \\
// 这个做法的时间复杂度是 $O(nlogn)$，因为每个节点直接继承了其子树中的重儿子，即每次只有轻儿子会被重复访问，访问完之后，轻儿子即会和重儿子进行合并，每次合并 $sz$ 至少乘 $2$，因此每个点最多被重复访问 $logn$ 次，即总时间复杂度为 $O(nlogn)$。\\
// \\
// 算法模板:\\
// 其实树上启发式合并并没有什么模板，只需要处理好两次 $dfs$ 的过程，然后实现插入、删除、更新三个函数即可。\\
// \\
// 以下面第一题的代码为例，给出一个大致的模板。\\
// ---
int sz[N],son[N];

void dfs1(int x){
	/* 求解重儿子 */
	sz[x] = 1;
	for(int i = head[x]; i; i = e[i].next){
		int y = e[i].to;
		dfs1(y); sz[x] += sz[y];
		if(sz[y] > sz[son[x]]) son[x] = y;
	}
}

void Delete(int x){
	/* 删除的内容 */
	for(int i = head[x]; i; i = e[i].next) Delete(e[i].to);
}

void modify(int x,int fa){
	/* 更新的内容 */
	for(int i = head[x]; i; i = e[i].next) modify(e[i].to,fa);
}

void ins(int x){
	/* 插入的内容 */
	for(int i = head[x]; i; i = e[i].next) ins(e[i].to);
}

void dfs2(int x){
	/* 求解轻儿子并清空 */
	for(int i = head[x]; i; i = e[i].next)
		if(e[i].to != son[x]) dfs2(e[i].to), Delete(e[i].to);
	
	/* 求解重儿子并保留 */
	if(son[x]) dfs2(son[x]);
	/* 用重儿子更新答案 */

	/* 枚举轻儿子更新答案，并加入轻儿子 */
	for(int i = head[x]; i; i = e[i].next) 
		if(e[i].to != son[x]) modify(e[i].to,x), ins(e[i].to);

	/* 用所有儿子更新答案 */
}